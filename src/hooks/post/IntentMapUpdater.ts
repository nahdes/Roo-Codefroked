/**
 * post/IntentMapUpdater.ts
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * POST-HOOK #2 â€” The Intent Map Updater
 *
 * After every tracked file write, updates the spatial index in
 * .orchestration/intent_map.md linking intent IDs to files.
 *
 * Errors are swallowed â€” never crashes the agent turn.
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 */

import * as fs from "fs"
import * as path from "path"
import { ToolContext } from "../HookEngine"
import { loadIntents } from "../utils/intentStore"
import { toRelativePath } from "../utils/gitUtils"

const MAP_FILE = ".orchestration/intent_map.md"
const PATH_PARAMS = ["path", "file_path", "target_file", "destination"]

const WRITE_TOOLS = new Set([
	"write_file",
	"write_to_file",
	"create_file",
	"apply_diff",
	"apply_patch",
	"edit",
	"search_and_replace",
	"search_replace",
	"edit_file",
	"insert_code_block",
	"replace_in_file",
])

export async function intentMapUpdater(ctx: ToolContext): Promise<ToolContext> {
	if (!WRITE_TOOLS.has(ctx.toolName) || !ctx.intentId) return ctx

	const targetPath = extractTargetPath(ctx)
	if (!targetPath) return ctx

	try {
		const absolutePath = path.isAbsolute(targetPath) ? targetPath : path.join(ctx.workspacePath, targetPath)
		const relativePath = toRelativePath(ctx.workspacePath, absolutePath)

		// Load existing map data from the <!--DATA:...--> comment in the markdown
		const mapPath = path.join(ctx.workspacePath, MAP_FILE)
		const existingData = loadMapData(mapPath)

		// Update the entry for this intent
		const entry = existingData.find((e) => e.intentId === ctx.intentId)
		if (entry) {
			if (!entry.files.includes(relativePath)) {
				entry.files.push(relativePath)
			}
			entry.mutationCount = (entry.mutationCount ?? 0) + 1
			entry.lastUpdated = new Date().toISOString()
		} else {
			existingData.push({
				intentId: ctx.intentId,
				intentName: ctx.intentId, // will be enriched below
				status: "IN_PROGRESS",
				files: [relativePath],
				lastUpdated: new Date().toISOString(),
				mutationCount: 1,
			})
		}

		// Enrich intent names from active_intents.yaml
		const intents = loadIntents(ctx.workspacePath)
		for (const d of existingData) {
			const intent = intents.find((i) => i.id === d.intentId)
			if (intent) {
				d.intentName = intent.name
				d.status = intent.status
			}
		}

		// Write the updated map
		const markdown = buildMapMarkdown(existingData)
		ensureDir(path.dirname(mapPath))
		fs.writeFileSync(mapPath, markdown, "utf8")
	} catch (err) {
		console.error("[IntentMapUpdater] Failed to update intent_map.md:", err)
	}

	return ctx
}

// â”€â”€ Data model â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface MapEntry {
	intentId: string
	intentName: string
	status: string
	files: string[]
	lastUpdated: string
	mutationCount: number
}

function loadMapData(mapPath: string): MapEntry[] {
	if (!fs.existsSync(mapPath)) return []
	try {
		const content = fs.readFileSync(mapPath, "utf8")
		const match = content.match(/<!--DATA:([\s\S]+?)-->/)
		if (!match) return []
		return JSON.parse(match[1]) as MapEntry[]
	} catch {
		return []
	}
}

function buildMapMarkdown(data: MapEntry[]): string {
	const now = new Date().toISOString()

	const rows = data
		.map((d) => {
			const status = statusEmoji(d.status) + " `" + d.status + "`"
			return `| ${d.intentId} | ${d.intentName} | ${status} | ${d.files.length} | ${d.mutationCount} | ${d.lastUpdated.slice(0, 16)} UTC |`
		})
		.join("\n")

	const sections = data
		.map((d) => {
			const fileRows = d.files.map((f) => `| \`${f}\` | â€” | â€” |`).join("\n")
			return `## ${d.intentId} â€” ${d.intentName}

**Status:** ${statusEmoji(d.status)} \`${d.status}\`
**Mutations:** ${d.mutationCount} | **Last updated:** ${d.lastUpdated.slice(0, 16)} UTC

### Files Modified

| File | Last Hash | Last Class |
|------|-----------|------------|
${fileRows || "| â€” | â€” | â€” |"}
`
		})
		.join("\n---\n\n")

	return `# Intent Map
> **Auto-generated by the IntentMapUpdater post-hook. Do not edit manually.**
> Last updated: \`${now}\`
> Total intents: ${data.length} | Total mutations: ${data.reduce((s, d) => s + d.mutationCount, 0)}

---

## Summary

| Intent ID | Intent Name | Status | Files | Mutations | Last Active |
|-----------|-------------|--------|-------|-----------|-------------|
${rows || "| â€” | â€” | â€” | â€” | â€” | â€” |"}

---

${sections}

<!--DATA:${JSON.stringify(data)}-->
`
}

function statusEmoji(status: string): string {
	const map: Record<string, string> = {
		IN_PROGRESS: "ðŸŸ¡",
		PENDING: "âšª",
		COMPLETE: "âœ…",
		BLOCKED: "ðŸ”´",
	}
	return map[status] ?? "âš«"
}

function extractTargetPath(ctx: ToolContext): string | null {
	for (const param of PATH_PARAMS) {
		const val = ctx.params[param]
		if (typeof val === "string" && val.length > 0) return val
	}
	return null
}

function ensureDir(dirPath: string): void {
	if (!fs.existsSync(dirPath)) fs.mkdirSync(dirPath, { recursive: true })
}
